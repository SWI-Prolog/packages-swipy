\documentclass[11pt]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{html}
\sloppy
\makeindex

\onefile
\htmloutput{.}					% Output directory
\htmlmainfile{janus}				% Main document file
\bodycolor{white}				% Page colour

\begin{document}

\title{SWI-Prolog Python interface}
\author{Jan Wielemaker \\
	SWI-Prolog Solutions b.v. \\
	E-mail: \email{jan@swi-prolog.org}}

\maketitle

\begin{abstract}
This package implements a bi-directional interface between Prolog and
Python using portable low-level primitives. The aim is to make Python
available to Prolog and visa versa with minimal installation effort
while providing a high level bi-directional interface with good
performance.
\end{abstract}

\pagebreak
\tableofcontents

\vfill
\vfill

\newpage

\section{Introduction}
\label{sec:janus-intro}

Unlike Prolog, Python has a huge set of resources, notably interfaces to
just about anything one can imagine. Making such interfaces available to
Prolog can surely be done. It typically requires programming in C or
C++, a skill that is not widely available everywhere. Being able to
access Python effortlessly from Prolog resolves that. This solution was
proposed in \cite{janus}, initially developed for XSB.

Janus provides a bi-directional interface between Prolog and Python
using the embedding interface. Currently we only implement using Python
embedded into SWI-Prolog. This makes using Python from Prolog as simple
as taking the standard SWI-Prolog distribution and loading
\pllib{janus}. Both being dynamically typed languages, we can define an
efficient and easy to use interface.

The Python interface is modeled after the recent JavaScript interface
developed for the WASM (Web Assembly) version.  That is

\begin{itemize}
    \item A di-directional data conversion is defined.  For SWI-Prolog,
    suporting dicts and strings, that is rather straightforward.
    Currently, where the JavaScript interface supports any Prolog
    term, the Python interface does not.  This may change.

    \item A Prolog predicate to call Python functions and object
    methods.

    \item A Python class \const{Prolog} that provides a Prolog
    query as an \jargon{iterator}.
\end{itemize}


\section{Data conversion}
\label{sec:janus-data}

The bi-directional conversion between Prolog and Python terms is
summarized in the table below.

\begin{center}
\begin{tabular}{|l|c|l|p{2in}|}
\hline
\textbf{Prolog} & & \textbf{Python} & \textbf{Notes} \\
\hline
Integer & $\Leftrightarrow$ & Integer  & Only 64 bit range \\
'None'  & $\Leftrightarrow$ & None     & \\
true    & $\Leftrightarrow$ & True     & \\
false   & $\Leftrightarrow$ & False    & \\
Atom    & $\rightarrow$     & String   & \\
String  & $\Leftrightarrow$ & String   & \\
\#(Term) & $\rightarrow$    & String   & \jargon{stringify} using write_canonical/1 if not atomic \\
List    & $\Leftrightarrow$ & Sequence & \\
\exam{''}(a,b,\ldots) & $\Leftrightarrow$ & (a,b,\ldots) & Python Tuples \\
Dict    & $\Leftrightarrow$ & Dict     & \\
\const{py_obj} blob & $\Leftrightarrow$ & Object & Used for any Python object not above \\ \hline
\end{tabular}
\end{center}

\input{libjanus.tex}

\section{Calling Prolog from Python}
\label{sec:janus-call-prolog}

The binding can also call Prolog from Python. This may be used to deal
with \jargon{call backs}. Future versions will allow this to be used
from Python using an embedded version of SWI-Prolog.

The Python module \const{janus} provides some utility functions and
defines the class \const{Prolog}. The class \const{Prolog} implements
the Python \jargon{iterator} protocol.  Below we iterate over the
solutions of between/3.  It is allowed to use \const{break} the
Python loop.

A Prolog goal is constructed from a string and \jargon{input bindings}
and returns \jargon{output bindings}.  For example

\begin{code}
>>> from janus import *
>>> once("Y is X+1", {"X":1})
{'Y': 2}
\end{code}

Note that the input argument may also be added literally. Below we give
two examples. It is strongly adviced \textbf{not to use string
interpolation} due to the risk for \jargon{injection attacks}. Also,
serializing and deserializing the data is generally slower then using
the input dictionary, especially if the data is large.

\begin{code}
>>> janus.once("Y is 1+1", {})
{'Y': 2}
>>> x = 1
>>> janus.once(f"Y is {x}+1", {})
{'Y': 2}
\end{code}

Using a dict for input and output together with a (short) string to
denote the goal is easy to use and fast.

The \jargon{output dict} contains all named Prolog variables that (1)
are not in the input dict and (2) do not start with an underscore. For
example, to get the grandparents of a person given parent/2 relations we
can use the code below, where the \arg{_GP} and \arg{_P} do not appear
in the output dict. This both saves time and avoids the need to convert
Prolog data structures that cannot be represented in Python such as
variables or arbitrary compound terms.

\begin{code}
>>> janus.once("findall(_GP, parent(Me, _P), parent(_P, _GP), GPs)", {'Me':'Jan'})["GPs"]
[ 'Kees', 'Klaas' ]
\end{code}

The class \ctype{janus.Query} implements a Python \jargon{iterator} that
iterates over the solutions of a Prolog goal. The iterator may be
aborted using the Python \exam{break} statement.

\begin{code}
from janus import *

def printRange(from, to):
    for d in Query("between(From,To,X)", {"From":from, "To":to})
        print(d["X"])
\end{code}

\begin{description}
    \cfunction{dict|False}{janus.once}{query, bindings}
Call \arg{query} using \arg{bindings} as once/1, returning either
a dict with resulting bindings or \const{False}.

    \cfunction{None}{janus.consult}{file}
Consult the given \arg{file}.  Implemented as
\exam{janus.once("consult(File)", {"File":file})}.

\end{description}

\section{Janus error handling}
\label{sec:janus-errors}

Exceptions are translated into exceptions in the other language both
ways. A Python exception translates into a Prolog exception of the shape
below. The library defines a rule for print_message/2 to render these
errors in a human readable way.

\begin{quote}
\term{error}{\term{python_error}{TypeObj, Value, Stack}, _}
\end{quote}

Prolog specific errors are passes as a Python exception of the type
\const{swipl.Error}.  The value is a string that contains the message
from the Prolog exception as generated by message_to_string/2.


\section{Janus performance evaluation}
\label{sec:janus-performance}

Below is a table to give some feeling on the overhead of making calls
between Prolog and Python. These figures are roughly the same as the
figures for the XSB/Python interface. All benchmarks have been executed
on AMD3950X running Ubuntu 22.04, SWI-Prolog 9.1.11 and Python 3.10.6.

\begin{center}
\begin{tabular}{|p{3in}|c|}
\hline
\textbf{Action} & \textbf{Time (seconds)} \\
\hline
Echo list with 1,000,000 elements & 0.142 \\
Call Pyton \exam{demo:sumlist3(5,[1,2,3])} from Prolog 1,000,000 times & 1.732 \\
Call Prolog \exam{Y is X+1} from Python 1,000,000 times & 3.791 \\
Iterate from Python over Prolog goal \exam{between(1, 1 000 000, X)} & 0.821 \\
\hline
\end{tabular}
\end{center}

\section{Python or C/C++ for accessing resources?}
\label{sec:janus-vs-c}

Using Python as an intermediate to access external resources allows
writing such interfaces with less effort by a much wider community. The
resulting interface is often also more robust due to well defined data
conversion and sound memory management that you get for free.

Nevertheless, Python often accesses resources with a C or C++ API. We
can also create this bridge directly, bypassing Python. That avoids one
layer of data conversion and preserves the excellent multi-threading
capabilities of SWI-Prolog. As is, Python operations are synchronised
using the Python \jargon{GIL}, a global lock that allows for only a
single thread to use Python at the same time.\footnote{There are rumours
that Python's multi threading will be able to use multiple cores.}

Writing an interface for SWI-Prolog is typically easier that for
Python/C because memory management is easier. Where we need to manage
reference counts to Python objects through all possibly paths of the C
functions, SWI-Prolog \ctype{term_t} merely has to be allocated once in
the function. All failure parts will discard the Prolog data
automatically through backtracking and all success paths will do so
through the Prolog garbage collector.\footnote{Using a Python C++
interface such as \href{https://github.com/pybind/pybind11}{pybind11}
simplifies memory management for a Python interface.}

Summarizing, the presented interface is ideal to get started quickly.
Applications that need to access C/C++ resources and need either exploit
all cores of your hardware or get the best performance on calls or
exchanging data should consider using the C or C++ interfaces of
SWI-Prolog.

\section{Compare to XSB Python interface}
\label{sec:janus-vs-xsb}

The XSB interface on which this work is based is different in several
ways.  We summarize the differences below

\begin{itemize}
   \item py_call/2 replaces pyfunc/[3,4,5] and pydot/[4,5].  The distinction
         between calling a function in a module or a method on an object is
         in both cases replaces by \arg{ObjOrMod}:\arg{Func} and Python
         keyword arguments are handled, as in Python, using optional
         \arg{Kwd}=\arg{Value} parameters after the positional parameters.

         The SWI-Prolog version allows for chaining function calls using
         \arg{Obj}:\arg{Func1}:\arg{Func2}:...  It also allows calling
         \jargon{built-in} functions such as print() by omiting the
         module or object.
   \item Data translation differs:
   \begin{itemize}
       \item Numbers are handled the same
       \item Python Booleans are translated to Prolog atoms \const{true}
             and \const{false} rather than the XSB 1 and 0.
       \item Python strings are translated to Prolog strings rather than
             XSB atoms.
       \item Python dicts are translated to Prolog dicts and visa versa.
             Note that Prolog dicts can only have atoms and small integers
             as keys.  Other Python dicts result in a representation error.
	     XSB uses \term{pyDict}{Tuple \ldots}.
       \item Tuples are handled the same.  We have some doubts about the
             use of \verb$''(a,b,c)$ because write/1 on this term produces
	     the confusing \verb$(a,b,c)$.  Possible we should opt for the
	     R representation \verb$c(a,b,c)$?
       \item Python objects that are not translated by any of the above
             are translated to a SWI-Prolog \jargon{blob}.  This makes
             identifying them robust and provides garbage collection.
	     XSB uses a term \arg{pyObj}{Ref}.
   \end{itemize}
   \item Python calling Prolog uses a string and dict for the input and
         gets the results as a dict.  The XSB version passes the module,
         predicate and arguments seperately and provides px_qdet(),
         px_cmd() and px_comp(), where px_comp() returns multiple
         solutions as a list.  We provide once() and a Python
         \jargon{iterator} by means of the class Prolog().
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\printindex

\end{document}

