\documentclass[11pt]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{html}
\sloppy
\makeindex

\onefile
\htmloutput{.}					% Output directory
\htmlmainfile{janus}				% Main document file
\bodycolor{white}				% Page colour

\begin{document}

\title{SWI-Prolog Python interface}
\author{Jan Wielemaker \\
	SWI-Prolog Solutions b.v. \\
	E-mail: \email{jan@swi-prolog.org}}

\maketitle

\begin{abstract}
This package implements a bi-directional interface between Prolog and
Python using portable low-level primitives. The aim is to make Python
available to Prolog and visa versa with minimal installation effort
while providing a high level bi-directional interface with good
performance.
\end{abstract}

\pagebreak
\tableofcontents

\vfill
\vfill

\newpage

\section{Introduction}
\label{sec:janus-intro}

Unlike Prolog, Python has a huge set of resources, notably interfaces to
just about anything one can imagine. Making such interfaces available to
Prolog can surely be done. It typically requires programming in C or
C++, a skill that is not widely available everywhere. Being able to
access Python effortlessly from Prolog resolves that. This solution was
proposed in \cite{janus}, initially developed for XSB.

Janus provides a bi-directional interface between Prolog and Python
using the embedding interface. Currently we only implement using Python
embedded into SWI-Prolog. This makes using Python from Prolog as simple
as taking the standard SWI-Prolog distribution and loading
\pllib{janus}. Both being dynamically typed languages, we can define an
efficient and easy to use interface.

The Python interface is modeled after the recent JavaScript interface
developed for the WASM (Web Assembly) version.  That is

\begin{itemize}
    \item A di-directional data conversion is defined.  For SWI-Prolog,
    supporting dicts and strings, that is rather straightforward.
    Currently, where the JavaScript interface supports any Prolog
    term, the Python interface does not.  This may change.

    \item A Prolog predicate to call Python functions, access and set
    object attributes.

    \item A non-deterministic Prolog predicate enumerate a Python
    \jargon{iterator}.

    \item A Python function once() to call a Prolog predicate as
    once/1 and return a dict with the bindings.

    \item A Python iterator class \const{Query} that provides
    access to non-deterministic Prolog predicates.
\end{itemize}


\section{Data conversion}
\label{sec:janus-data}

The bi-directional conversion between Prolog and Python terms is
summarized in the table below.  For compatibility with Prolog
implementation we support converting the curly-bracket and
\arg{k}:\arg{v} to dicts.  Note that \verb${k1:v1, k2:v2}$ is
syntactic sugar for \verb${}(','(:(k1,v1), :(k2,v2)))$.  We allow for
embedding this in a \term{py}{Term} such that, with \const{py} defined
as \jargon{prefix operator}, \verb$py{k1:v1, k2:v2}$ is both valid
syntax as SWI-Prolog dict as as ISO Prolog compliant term and both are
translated into the same Python dict.


\begin{center}
\begin{tabular}{|l|c|l|p{2in}|}
\hline
\textbf{Prolog} & & \textbf{Python} & \textbf{Notes} \\
\hline
Integer & $\Leftrightarrow$ & Integer  & Only 64 bit range \\
'None'  & $\Leftrightarrow$ & None     & \\
true    & $\Leftrightarrow$ & True     & \\
false   & $\Leftrightarrow$ & False    & \\
Atom    & $\rightarrow$     & String   & \\
String  & $\Leftrightarrow$ & String   & \\
\#(Term) & $\rightarrow$    & String   & \jargon{stringify} using write_canonical/1 if not atomic \\
List    & $\Leftrightarrow$ & Sequence & \\
:(a,b,\ldots) & $\Leftrightarrow$ & (a,b,\ldots) & Python Tuples \\
Dict    & $\Leftrightarrow$ & Dict     & \\
\{k:v,\ldots\} & $\rightarrow$ & Dict    & Compatibility (see above) \\
py(\{k:v,\ldots\}) & $\rightarrow$ & Dict & Compatibility (see above) \\
\const{py_obj} blob & $\Leftrightarrow$ & Object & Used for any Python object not above \\
hline
\end{tabular}
\end{center}

\input{libjanus.tex}

\input{jnsutils.tex}

\section{Calling Prolog from Python}
\label{sec:janus-call-prolog}

The binding can also call Prolog from Python. This may be used to deal
with \jargon{call backs}. Future versions will allow this to be used
from Python using an embedded version of SWI-Prolog.

The Python module \const{janus} provides some utility functions and
defines the class \const{Prolog}. The class \const{Query} implements
the Python \jargon{iterator} protocol.  Below we iterate over the
solutions of between/3.  It is allowed to use \const{break} the
Python loop.

A Prolog goal is constructed from a string and \jargon{input bindings}
and returns \jargon{output bindings}.  For example

\begin{code}
>>> from janus import *
>>> once("Y is X+1", {"X":1})
{'Y': 2, 'status': True}
\end{code}

Note that the input argument may also be added literally. Below we give
two examples. It is strongly advised \textbf{not to use string
interpolation} due to the risk for \jargon{injection attacks}. Also,
serializing and deserializing the data is generally slower then using
the input dictionary, especially if the data is large.

\begin{code}
>>> janus.once("Y is 1+1", {})
{'Y': 2, 'status': True}
>>> x = 1
>>> janus.once(f"Y is {x}+1", {})
{'Y': 2, 'status': True}
\end{code}

Using a dict for input and output together with a (short) string to
denote the goal is easy to use and fast.

The \jargon{output dict} contains all named Prolog variables that (1)
are not in the input dict and (2) do not start with an underscore. For
example, to get the grandparents of a person given parent/2 relations we
can use the code below, where the \arg{_GP} and \arg{_P} do not appear
in the output dict. This both saves time and avoids the need to convert
Prolog data structures that cannot be represented in Python such as
variables or arbitrary compound terms.

\begin{code}
>>> janus.once("findall(_GP, parent(Me, _P), parent(_P, _GP), GPs)", {'Me':'Jan'})["GPs"]
[ 'Kees', 'Klaas' ]
\end{code}

The class janus.Query() implements a Python \jargon{iterator} that
iterates over the solutions of a Prolog goal. The iterator may be
aborted using the Python \exam{break} statement.  As with janus.once(),
the returned dict contains a \const{status} field.  This field cannot
be \const{False} though and thus is either \const{True} or the string
\verb$'Undefined'$.

\begin{code}
from janus import *

def printRange(from, to):
    for d in Query("between(From,To,X)", {"From":from, "To":to})
        print(d["X"])
\end{code}

\begin{description}
    \cfunction{dict}{janus.once}{query, bindings=\{{}\}, keep=False}
Call \arg{query} using \arg{bindings} as once/1, returning a dict with
the resulting bindings. If \arg{bindings} is omitted, no variables are
bound. The \arg{keep} parameter determines whether or not Prolog
discards all backtrackable changes.  By default, such changes are
discarded and as a result, changes to backtrackable global variables
are lost.  Using \const{True}, such changes are preserved.

\begin{code}
>>> once("b_setval(a, 1)", keep=True)
{'status': 'True'}
>>> once("b_getval(a, X)")
{'status': 'True', 'X': 1}
\end{code}

If \arg{query} fails, the variables of the query are bound to the Python
constant \const{None}. The \arg{bindings} object includes a key
\const{status}\footnote{As this name is not a valid Prolog variable
name, this cannot be ambiguous.} that has the value \const{False} (query
failed, all bindings are \const{None}), \const{True} (query succeeded,
variables are bound to the result converting Prolog data to Python) or
\verb$'Undefined'$, a Python string that indicates the answer is
undefined according to the \jargon{Well Founded Semantics}. See e.g.,
undefined/0. For example

\begin{code}
>>> from janus import *
>>> once("undefined")
{'status': 'Undefined'}
\end{code}

    \cfunction{None}{janus.consult}{file}
Consult the given \arg{file}.  Implemented as
\exam{janus.once("consult(File)", {"File":file})}.
\end{description}

\section{Janus and threads}
\label{sec:janus-threads}

Where SWI-Prolog support native preemptively scheduled threads that
exploit multiple cores, Python has a single interpreter that can switch
between native threads.\footnote{Actually, you can create multiple
Python interpreters. It is not yet clear to us whether that can help
improving on concurrency.} Initially the Python interpreter is
associated with the thread that created it which, for janus, is the
first thread calling Python. Janus uses PyGILState_Ensure() and
PyGILState_Release() around calls to e.g. py_call/2. In addition, the
thread that created Python releases its interpreter after every call
from Prolog on Python. As a result:

\begin{itemize}
    \item Multiple Prolog threads can make calls to Python.  The
    access to Python is \jargon{serialized}.  If a Prolog thread
    does not want other threads to use Python it can use
    py_with_gil/1.  When multiple Prolog threads make many
    calls to Python performance tends to drop significantly.

    \item Multiple Python threads can make calls to Prolog.  As
    Python uses only one core at the same time, Prolog working
    on behalve of Python \jargon{synchronously} only uses one
    core.  Prolog threads not related to Python can proceed
    on other cores.

    \item Python threading is \jargon{cooperative}.  At the
    moment, a thread Python thread running Prolog will not
    allow other Python threads to make progress.  Possibly that
    can be improved in the future.

    \item It appears to be possible to initialize Python in a
    thread.   Python remains accessible from other threads after
    the initializing thread has terminated.
\end{itemize}


\section{Janus error handling}
\label{sec:janus-errors}

Exceptions are translated into exceptions in the other language both
ways. A Python exception translates into a Prolog exception of the shape
below. The library defines a rule for print_message/2 to render these
errors in a human readable way.

\begin{quote}
\term{error}{\term{python_error}{TypeObj, Value, Stack}, _}
\end{quote}

Prolog specific errors are passes as a Python exception of the type
\const{swipl.Error}.  The value is a string that contains the message
from the Prolog exception as generated by message_to_string/2.

\section{Prolog and Python}
\label{sec:janus-prolog-python}

Prolog is a very different language than imperative languages.  An
interesting similarity is the notion of \jargon{backtracking} vs.
Python \jargon{iterators}.


\section{Janus performance evaluation}
\label{sec:janus-performance}

Below is a table to give some feeling on the overhead of making calls
between Prolog and Python. These figures are roughly the same as the
figures for the XSB/Python interface. All benchmarks have been executed
on AMD3950X running Ubuntu 22.04, SWI-Prolog 9.1.11 and Python 3.10.6.

\begin{center}
\begin{tabular}{|p{3in}|c|}
\hline
\textbf{Action} & \textbf{Time (seconds)} \\
\hline
Echo list with 1,000,000 elements & 0.12 \\
Call Pyton \exam{demo:int()} from Prolog 1,000,000 times & 0.44 \\
Call Pyton \exam{demo:sumlist3(5,[1,2,3])} from Prolog 1,000,000 times & 1.4 \\
Call Prolog \exam{Y is X+1} from Python 1,000,000 times & 3.7 \\
Iterate from Python over Prolog goal \exam{between(1, 1 000 000, X)} & 1.1 \\
Iterate over Python iterator \exam{range(1,1000000)} from Prolog & 0.17 \\
\hline
\end{tabular}
\end{center}

\section{Python or C/C++ for accessing resources?}
\label{sec:janus-vs-c}

Using Python as an intermediate to access external resources allows
writing such interfaces with less effort by a much wider community. The
resulting interface is often also more robust due to well defined data
conversion and sound memory management that you get for free.

Nevertheless, Python often accesses resources with a C or C++ API. We
can also create this bridge directly, bypassing Python. That avoids one
layer of data conversion and preserves the excellent multi-threading
capabilities of SWI-Prolog. As is, Python operations are synchronized
using the Python \jargon{GIL}, a global lock that allows for only a
single thread to use Python at the same time.\footnote{There are rumors
that Python's multi threading will be able to use multiple cores.}

Writing an interface for SWI-Prolog is typically easier that for
Python/C because memory management is easier. Where we need to manage
reference counts to Python objects through all possibly paths of the C
functions, SWI-Prolog \ctype{term_t} merely has to be allocated once in
the function. All failure parts will discard the Prolog data
automatically through backtracking and all success paths will do so
through the Prolog garbage collector.\footnote{Using a Python C++
interface such as \href{https://github.com/pybind/pybind11}{pybind11}
simplifies memory management for a Python interface.}

Summarizing, the presented interface is ideal to get started quickly.
Applications that need to access C/C++ resources and need either exploit
all cores of your hardware or get the best performance on calls or
exchanging data should consider using the C or C++ interfaces of
SWI-Prolog.

\section{Compare to XSB Python interface}
\label{sec:janus-vs-xsb}

The XSB interface on which this work is based is different in several
ways.  We summarize the differences below

\begin{itemize}
   \item py_call/2 replaces pyfunc/[3,4,5] and pydot/[4,5].  The distinction
         between calling a function in a module or a method on an object is
         in both cases replaces by \arg{ObjOrMod}:\arg{Func} and Python
         keyword arguments are handled, as in Python, using optional
         \arg{Kwd}=\arg{Value} parameters after the positional parameters.

         The SWI-Prolog version allows for chaining function calls using
         \arg{Obj}:\arg{Func1}:\arg{Func2}:...  It also allows calling
         \jargon{built-in} functions such as print() by omitting the
         module or object.

	 Finally, it allow setting attributes using py_call(Obj:Attr =
	 Value)
   \item py_iter/2 Allows accessing Python iteractors as non-deterministic
         Prolog predicates.
   \item Data translation differs:
   \begin{itemize}
       \item Numbers are handled the same
       \item Python Booleans are translated to Prolog atoms \const{true}
             and \const{false} rather than the XSB 1 and 0.
       \item Python strings are translated to Prolog strings rather than
             XSB atoms.
       \item Python dicts are translated to Prolog dicts and visa versa.
             Note that Prolog dicts can only have atoms and small integers
             as keys.  Other Python dicts result in a representation error.
	     XSB uses \term{pyDict}{Tuple \ldots}.
       \item Tuples are handled the same.  We have some doubts about the
             use of \verb$''(a,b,c)$ because write/1 on this term produces
	     the confusing \verb$(a,b,c)$.  Possible we should opt for the
	     R representation \verb$c(a,b,c)$?
       \item Python objects that are not translated by any of the above
             are translated to a SWI-Prolog \jargon{blob}.  This makes
             identifying them robust and provides garbage collection.
	     XSB uses a term \arg{pyObj}{Ref}.
   \end{itemize}
   \item Python calling Prolog uses a string and dict for the input and
         gets the results as a dict.  The XSB version passes the module,
         predicate and arguments seperately and provides px_qdet(),
         px_cmd() and px_comp(), where px_comp() returns multiple
         solutions as a list.  We provide once() and a Python
         \jargon{iterator} by means of the class Prolog().
   \item py_free/1 is identical to free_python_object/1 in XSB.  Where
         free_python_object/1 is obligatory to avoid memory leaks,
	 py_free/1 is optional as garbage collection will eventually
	 deal with the object.
\end{itemize}

\section{Status of Janus}
\label{sec:janus-status}

The current version of this Janus library is experimental.

\begin{itemize}
    \item The design is stable
    \item Naming of predicates and Python functions may change
    \item Prolog representation of Python data may change
    \item Testing is minimal.  Crashes are not impossible.
    \item The module must become loadable from Python, embedding
          Prolog.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\printindex

\end{document}

