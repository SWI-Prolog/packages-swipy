\documentclass[11pt]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{html}
\sloppy
\makeindex

\onefile
\htmloutput{.}					% Output directory
\htmlmainfile{janus}				% Main document file
\bodycolor{white}				% Page colour

\begin{document}

\title{SWI-Prolog Python interface}
\author{Jan Wielemaker \\
	SWI-Prolog Solutions b.v. \\
	E-mail: \email{jan@swi-prolog.org}}

\maketitle

\begin{abstract}
This package implements a bi-directional interface between Prolog and
Python using portable low-level primitives. The aim is to make Python
available to Prolog and visa versa with minimal installation effort
while providing a high level bi-directional interface with good
performance.
\end{abstract}

\pagebreak
\tableofcontents

\vfill
\vfill

\newpage

\section{Introduction}
\label{sec:janus-intro}

Python has a huge developer community that maintains a large set of
resources, notably interfaces to just about anything one can imagine.
Making such interfaces directly available to Prolog can surely be done.
However, developing an interface typically requires programming in C or
C++, a skill that is not widely available everywhere. Being able to
access Python effortlessly from Prolog resolves that. This solution was
proposed in \cite{janus}, initially developed for XSB.

Janus provides a bi-directional interface between Prolog and Python
using the low-level C API of both languages. Currently we only support
Python embedded into SWI-Prolog. This makes using Python from Prolog as
simple as taking the standard SWI-Prolog distribution and loading
\pllib{janus}. Both being dynamically typed languages, we can define an
efficient and easy to use interface.

The Python interface is modeled after the recent JavaScript interface
developed for the WASM (Web Assembly) version.  That is

\begin{itemize}
    \item A di-directional data conversion is defined.  For SWI-Prolog,
    supporting dicts and strings, that is rather straightforward.
    Currently, where the JavaScript interface supports any Prolog
    term, the Python interface does not.  This may change.

    \item A Prolog predicate to call Python functions and methods,
    as well as access and set object attributes.

    \item A non-deterministic Prolog predicate enumerate a Python
    \jargon{iterator}.

    \item A Python function once() to call a Prolog predicate as
    once/1 and return a dict with the bindings.

    \item A Python iterator class \const{Query} that provides
    access to non-deterministic Prolog predicates.
\end{itemize}


\section{Data conversion}
\label{sec:janus-data}

The bi-directional conversion between Prolog and Python terms is
summarized in the table below.  For compatibility with Prolog
implementations without native dicts we support converting the
curly-bracket and \arg{k}:\arg{v} to dicts.  Note that
\verb${k1:v1, k2:v2}$ is syntactic sugar for
\verb${}(','(:(k1,v1), :(k2,v2)))$.  We allow for embedding this in a
\term{py}{Term} such that, with \const{py} defined as \jargon{prefix
  operator}, \verb$py{k1:v1, k2:v2}$ is both valid syntax as
SWI-Prolog dict as as ISO Prolog compliant term and both are
translated into the same Python dict.

Note that by default we translate Python strings into Prolog atoms.
Given we support strings, this is somewhat dubious.  There are two
reasons for this choice.  One is the pragmatic reason that Python uses
strings both for \jargon{identifiers} and arbitrary text.  Ideally
we'd have the first translated to Prolog atoms and the latter to
Prolog strings, but this is not possible.  The second is to improve
compatibility with Prolog systems that do not support strings.  Note
that py_call/3 and py_iiter/3 provide the option
\term{py_string_as}{string} to obtain a string if this is desirable.

\begin{center}
\begin{tabular}{|l|c|l|p{2in}|}
\hline
\textbf{Prolog} & & \textbf{Python} & \textbf{Notes} \\
\hline
Integer & $\Longleftrightarrow$ & Integer  & Supports big integers \\
'None'  & $\Longleftrightarrow$ & None     & \\
true    & $\Longleftrightarrow$ & True     & \\
false   & $\Longleftrightarrow$ & False    & \\
Atom    & $\longleftrightarrow$ & String   & Except the above reserved three atoms \\
String  & $\longrightarrow$     & String   & \\
\#(Term) & $\longrightarrow$    & String   & \jargon{stringify} using write_canonical/1 if not atomic \\
List    & $\longrightarrow$     & List & \\
List    & $\longleftarrow$      & Sequence & \\
List    & $\longleftarrow$      & Generator & \\
:(a,b,\ldots) & $\Longleftrightarrow$ & (a,b,\ldots) & Python Tuples \\
Dict    & $\Longleftrightarrow$ & Dict     & \\
\{k:v,\ldots\} & $\Longrightarrow$ & Dict    & Compatibility (see above) \\
py(\{k:v,\ldots\}) & $\Longrightarrow$ & Dict & Compatibility (see above) \\
\const{py_obj} blob & $\Longleftrightarrow$ & Object & Used for any Python object not above \\
\hline
\end{tabular}
\end{center}

\section{Janus by example}
\label{sec:janus-examples}

This section introduces Janus by examples.

\subsection{Janus callint spaCy}
\label{sec:janus-spacy}

The \href{https://spacy.io/}{spaCy} package provides natural language
processing.   This section illustrates the Janus library using spaCy.
Typically, spaCy and the English language models may be installed using

\begin{code}
> pip install spacy
> python -m spacy download en
\end{code}

After spaCy is installed, we can define \nopredref{model}{1} to
represent a Python object for the English language model using the
code below.  Note that by tabling this code as shared, the model is
loaded only once and is accessible from multiple Prolog threads.

\begin{code}
:- table english/1 as shared.

english(NLP) :-
    py_call(spacy:load(en_core_web_sm), NLP).
\end{code}

Calling \term{english}{X} results in \arg{X} =
\verb$<py_English>(0x7f703c24f430)$.  This object implements the
Python \jargon{callable} protocol.  Calling the model with a string
results in a parsed document.   We can use this from Prolog using
the built-in \const{__call__} method:

\begin{code}
?- english(NLP),
   py_call(NLP:'__call__'("This is a sentence."), Doc).
NLP = <py_English>(0x7f703851b8e0),
Doc = [<py_Token>(0x7f70375be9d0), <py_Token>(0x7f70375be930),
       <py_Token>(0x7f70387f8860), <py_Token>(0x7f70376dde40),
       <py_Token>(0x7f70376de200)
      ].
\end{code}

This is not what we want.  Because the spaCy \const{Doc} class
implements the \jargon{sequence} protocol it is translated into a
Prolog list of spaCy \const{Token} instances.  The \const{Doc} class
implements many more methods that we may wish to use.  An example is
\const{noun_chunks}, which provides a Python \jargon{generator} that
enumerates the noun chunks found in the input.  Each chunk is an
instance of \const{Span}, a sequence of \const{Token} instances that
have the property \const{text}.  So, if we want the noun chunks as
text, we can write the following program:

\begin{code}
:- use_module(library(janus)).

:- table english/1.

english(NLP) :-
    py_call(spacy:load(en_core_web_sm),NLP).

noun(Sentence, Noun) :-
    english(NLP),
    py_call(NLP:'__call__'(Sentence), Doc, [py_object(true)]),
    py_iter(Doc:noun_chunks, Span, [py_object]),
    py_call(Span:text, Noun).
\end{code}

After which we can call

\begin{code}
?- noun("This is a sentence.", Noun).
Noun = 'This' ;
Noun = 'a sentence'.
\end{code}

\input{libjanus.tex}

\input{jnsutils.tex}

\section{Calling Prolog from Python}
\label{sec:janus-call-prolog}

The binding can also call Prolog from Python. This may be used to deal
with \jargon{call backs}. Future versions will allow this to be used
from Python using an embedded version of SWI-Prolog.

The Python module \const{janus} provides some utility functions and
defines the class \const{Prolog}. The class \const{Query} implements
the Python \jargon{iterator} protocol.  Below we iterate over the
solutions of between/3.  It is allowed to use \const{break} the
Python loop.

A Prolog goal is constructed from a string and \jargon{input bindings}
and returns \jargon{output bindings}.  For example

\begin{code}
>>> from janus import *
>>> once("Y is X+1", {"X":1})
{'Y': 2, 'status': True}
\end{code}

Note that the input argument may also be added literally. Below we give
two examples. It is strongly advised \textbf{not to use string
interpolation} due to the risk for \jargon{injection attacks}. Also,
serializing and deserializing the data is generally slower then using
the input dictionary, especially if the data is large.

\begin{code}
>>> janus.once("Y is 1+1", {})
{'Y': 2, 'status': True}
>>> x = 1
>>> janus.once(f"Y is {x}+1", {})
{'Y': 2, 'status': True}
\end{code}

Using a dict for input and output together with a (short) string to
denote the goal is easy to use and fast.

The \jargon{output dict} contains all named Prolog variables that (1)
are not in the input dict and (2) do not start with an underscore. For
example, to get the grandparents of a person given parent/2 relations we
can use the code below, where the \arg{_GP} and \arg{_P} do not appear
in the output dict. This both saves time and avoids the need to convert
Prolog data structures that cannot be represented in Python such as
variables or arbitrary compound terms.

\begin{code}
>>> janus.once("findall(_GP, parent(Me, _P), parent(_P, _GP), GPs)", {'Me':'Jan'})["GPs"]
[ 'Kees', 'Klaas' ]
\end{code}

The class janus.Query() implements a Python \jargon{iterator} that
iterates over the solutions of a Prolog goal. The iterator may be
aborted using the Python \exam{break} statement.  As with janus.once(),
the returned dict contains a \const{status} field.  This field cannot
be \const{False} though and thus is either \const{True} or the string
\verb$'Undefined'$.

\begin{code}
from janus import *

def printRange(from, to):
    for d in Query("between(From,To,X)", {"From":from, "To":to})
        print(d["X"])
\end{code}

\begin{description}
    \cfunction{dict}{janus.once}{query, bindings=\{{}\}, keep=False}
Call \arg{query} using \arg{bindings} as once/1, returning a dict with
the resulting bindings. If \arg{bindings} is omitted, no variables are
bound. The \arg{keep} parameter determines whether or not Prolog
discards all backtrackable changes.  By default, such changes are
discarded and as a result, changes to backtrackable global variables
are lost.  Using \const{True}, such changes are preserved.

\begin{code}
>>> once("b_setval(a, 1)", keep=True)
{'status': 'True'}
>>> once("b_getval(a, X)")
{'status': 'True', 'X': 1}
\end{code}

If \arg{query} fails, the variables of the query are bound to the Python
constant \const{None}. The \arg{bindings} object includes a key
\const{status}\footnote{As this name is not a valid Prolog variable
name, this cannot be ambiguous.} that has the value \const{False} (query
failed, all bindings are \const{None}), \const{True} (query succeeded,
variables are bound to the result converting Prolog data to Python) or
\verb$'Undefined'$, a Python string that indicates the answer is
undefined according to the \jargon{Well Founded Semantics}. See e.g.,
undefined/0. For example

\begin{code}
>>> from janus import *
>>> once("undefined")
{'status': 'Undefined'}
\end{code}

    \cfunction{None}{janus.consult}{file}
Consult the given \arg{file}.  Implemented as
\exam{janus.once("consult(File)", {"File":file})}.
\end{description}

\section{Janus and threads}
\label{sec:janus-threads}

Where SWI-Prolog support native preemptively scheduled threads that
exploit multiple cores, Python has a single interpreter that can switch
between native threads.\footnote{Actually, you can create multiple
Python interpreters. It is not yet clear to us whether that can help
improving on concurrency.} Initially the Python interpreter is
associated with the thread that created it which, for janus, is the
first thread calling Python. Janus uses PyGILState_Ensure() and
PyGILState_Release() around calls to e.g. py_call/2. In addition, the
thread that created Python releases its interpreter after every call
from Prolog on Python. As a result:

\begin{itemize}
    \item Multiple Prolog threads can make calls to Python.  The
    access to Python is \jargon{serialized}.  If a Prolog thread
    does not want other threads to use Python it can use
    py_with_gil/1.  When multiple Prolog threads make many
    calls to Python performance tends to drop significantly.

    \item Multiple Python threads can make calls to Prolog.  As
    Python uses only one core at the same time, Prolog working
    on behalve of Python \jargon{synchronously} only uses one
    core.  Prolog threads not related to Python can proceed
    on other cores.

    \item Python threading is \jargon{cooperative}.  At the
    moment, a thread Python thread running Prolog will not
    allow other Python threads to make progress.  Possibly that
    can be improved in the future.

    \item It appears to be possible to initialize Python in a
    thread.   Python remains accessible from other threads after
    the initializing thread has terminated.
\end{itemize}


\section{Janus error handling}
\label{sec:janus-errors}

Exceptions are translated into exceptions in the other language both
ways. A Python exception translates into a Prolog exception of the shape
below. The library defines a rule for print_message/2 to render these
errors in a human readable way.

\begin{quote}
\term{error}{\term{python_error}{TypeObj, Value, Stack}, _}
\end{quote}

Prolog specific errors are passes as a Python exception of the type
\const{swipl.Error}.  The value is a string that contains the message
from the Prolog exception as generated by message_to_string/2.

\section{Prolog and Python}
\label{sec:janus-prolog-python}

Prolog is a very different language than imperative languages.  An
interesting similarity is the notion of \jargon{backtracking} vs.
Python \jargon{iterators}.


\section{Janus performance evaluation}
\label{sec:janus-performance}

Below is a table to give some feeling on the overhead of making calls
between Prolog and Python. These figures are roughly the same as the
figures for the XSB/Python interface. All benchmarks have been executed
on AMD3950X running Ubuntu 22.04, SWI-Prolog 9.1.11 and Python 3.10.6.

\begin{center}
\begin{tabular}{|p{3in}|c|}
\hline
\textbf{Action} & \textbf{Time (seconds)} \\
\hline
Echo list with 1,000,000 elements & 0.12 \\
Call Pyton \exam{demo:int()} from Prolog 1,000,000 times & 0.44 \\
Call Pyton \exam{demo:sumlist3(5,[1,2,3])} from Prolog 1,000,000 times & 1.4 \\
Call Prolog \exam{Y is X+1} from Python 1,000,000 times & 1.9 \\
Iterate from Python over Prolog goal \exam{between(1, 1 000 000, X)} & 1.1 \\
Iterate over Python iterator \exam{range(1,1000000)} from Prolog & 0.17 \\
\hline
\end{tabular}
\end{center}

\section{Python or C/C++ for accessing resources?}
\label{sec:janus-vs-c}

Using Python as an intermediate to access external resources allows
writing such interfaces with less effort by a much wider community. The
resulting interface is often also more robust due to well defined data
conversion and sound memory management that you get for free.

Nevertheless, Python often accesses resources with a C or C++ API. We
can also create this bridge directly, bypassing Python. That avoids one
layer of data conversion and preserves the excellent multi-threading
capabilities of SWI-Prolog. As is, Python operations are synchronized
using the Python \jargon{GIL}, a global lock that allows for only a
single thread to use Python at the same time.\footnote{There are rumors
that Python's multi threading will be able to use multiple cores.}

Writing an interface for SWI-Prolog is typically easier that for
Python/C because memory management is easier. Where we need to manage
reference counts to Python objects through all possibly paths of the C
functions, SWI-Prolog \ctype{term_t} merely has to be allocated once in
the function. All failure parts will discard the Prolog data
automatically through backtracking and all success paths will do so
through the Prolog garbage collector.\footnote{Using a Python C++
interface such as \href{https://github.com/pybind/pybind11}{pybind11}
simplifies memory management for a Python interface.}

Summarizing, the presented interface is ideal to get started quickly.
Applications that need to access C/C++ resources and need either exploit
all cores of your hardware or get the best performance on calls or
exchanging data should consider using the C or C++ interfaces of
SWI-Prolog.

\section{Compatibility to the XSB Janus implementation}
\label{sec:janus-vs-xsb}

We aim to provide an interface that is close enough to allow
developing Prolog code that uses Python and visa versa.  Differences
between the two Prolog implementation make this non-trivial.
SWI-Prolog has native support for \jargon{dicts}, \jargon{strings},
\jargon{unbounded integers} and \jargon{blobs} that provide safe
pointers to external objects that are subject to (atom) garbage
collection.

We try to find a compromise to make the data conversion as close as
possible while supporting both systems as good as possible.  For this
reason we support creating a Python dict both from a SWI-Prolog dict
and from the Prolog term \verb$py({k1:v1, k2:v2, ...})$.  With
\const{py} defined as a prefix operator, this may be written without
parenthesis and is thus equivalent to the SWI-Prolog dict syntax.
The \pllib{jns_util} library provides access predicates that are
supported by both systems and where the SWI-Prolog version supports
both SWI-Prolog dicts and the above Prolog representation.

Both implementations will provide a low-level and more high level
interface.  The high level interface is realized by py_call/2 and
py_iter/2 from Prolog and janus.once() and janus.Query() from Python.
We realize the low level interfaces pyfunc/[3,4,5] and pydot/[4,5] on
top of py_call/2 and the Python functions px_cmd(), px_qdet() and
px_comp() on top of janus.once().  Emulation of the Prolog predicates
is shallow and has little impact on performance.  Emulation of the
Python functions on top of janus.once() is more expensive.  Future
versions of the SWI-Prolog implementation may opt for a more low-level
implementation.

While we are discussing to minimize the differences we highlight the
remaining issues below.

\begin{itemize}
   \item All Python list-like results are translated into a Prolog
     list.  To be precise, we translate Python objects that
     implement one of these protocols: \const{PyList}, \const{PyIter}
     and \const{PySequence}.   XSB translates \const{PyList} to a list
     and \const{PySet} to a term \term{pySet}{List}.  Sequences and
     iterators are returned as Python objects.  The user typically
     has to write a Python function to create a suitable intermediate
     Python representation.

   \item py_iter/2 Allows accessing Python iteractors and generators as
     non-deterministic Prolog predicates.

   \item We provide py_call/3 and py_iter/3 with an option argument to
     get a string rather than an atom from a Python string and force
     to get a Python object reference rather than a translated version.

   \item Data translation differs:
   \begin{itemize}
       \item Numbers are handled the same
       \item Python dicts are translated to Prolog dicts and visa versa.
             Note that Prolog dicts can only have atoms and small integers
             as keys.  Other Python dicts result in a representation error.
	     XSB uses \term{py}{\{k:v, \ldots\}}.
       \item Python objects that are not translated by any of the above
             are translated to a SWI-Prolog \jargon{blob}.  This makes
             identifying them robust and provides garbage collection.
	     XSB uses a term \arg{pyObj}{Ref} and requires py_free/1.
   \end{itemize}
\end{itemize}

\section{Status of Janus}
\label{sec:janus-status}

The current version of this Janus library must be considered \jargon{alpha}
code.

\begin{itemize}
    \item The design is stable
    \item Testing is minimal.  Crashes are not impossible.
    \item The module must become loadable from Python, embedding
          Prolog.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\printindex

\end{document}

